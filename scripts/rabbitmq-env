#!/bin/sh -e
##  The contents of this file are subject to the Mozilla Public License
##  Version 1.1 (the "License"); you may not use this file except in
##  compliance with the License. You may obtain a copy of the License
##  at http://www.mozilla.org/MPL/
##
##  Software distributed under the License is distributed on an "AS IS"
##  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
##  the License for the specific language governing rights and
##  limitations under the License.
##
##  The Original Code is RabbitMQ.
##
##  The Initial Developer of the Original Code is GoPivotal, Inc.
##  Copyright (c) 2007-2015 Pivotal Software, Inc.  All rights reserved.
##
set -e

if [ "$RABBITMQ_ENV_LOADED" = 1 ]; then
    return 0;
fi

_rmq_env_now()
{
    date '+%Y-%m-%d %H:%M:%S'
}

_rmq_env_perr()
{
    echo "$(_rmq_env_now) [error]: $*" 1>&2
}

_rmq_env_initialize()
{
    if [ -z "$RABBITMQ_SCRIPTS_DIR" ]; then
        # We set +e here since since our test for "readlink -f" below needs to
        # be able to fail.
        set +e
        # Determine where this script is really located (if this script is
        # invoked from another script, this is the location of the caller)
        _rmq_env_script_path="$_rmq_env_0"
        while [ -h "$_rmq_env_script_path" ] ; do
            # Determine if readlink -f is supported at all. TODO clean this up.
            _rmq_env_full_path="$(readlink -f "$_rmq_env_script_path" 2>/dev/null)"
            # shellcheck disable=SC2181
            if [ $? != 0 ]
            then
                _rmq_env_rel_path="$(readlink "$_rmq_env_script_path")"
                if expr "$_rmq_env_rel_path" : '/.*' > /dev/null; then
                    _rmq_env_script_path="$_rmq_env_rel_path"
                else
                    _rmq_env_script_path="$(dirname "$_rmq_env_script_path")/$_rmq_env_rel_path"
                fi
                else
                _rmq_env_script_path=$_rmq_env_full_path
            fi
        done

        RABBITMQ_SCRIPTS_DIR="$(dirname "$_rmq_env_script_path")"
        unset _rmq_env_script_path
        unset _rmq_env_full_path
        unset _rmq_env_rel_path
    fi

    set -e

    RABBITMQ_HOME="$(_rmq_env_realpath "$RABBITMQ_SCRIPTS_DIR/..")"

    # shellcheck disable=SC2034
    ESCRIPT_DIR="$RABBITMQ_HOME/escript"

    ## Set defaults
    if [ -f "$RABBITMQ_SCRIPTS_DIR"/rabbitmq-defaults ]
    then
        # shellcheck source=/dev/null
        . "$RABBITMQ_SCRIPTS_DIR"/rabbitmq-defaults
    else
        _rmq_env_perr "could not source $RABBITMQ_SCRIPTS_DIR/rabbitmq-defaults file"
        return 1
    fi

    ## Get configuration variables from the configure environment file
    if [ -z "$RABBITMQ_CONF_ENV_FILE" ]
    then
        RABBITMQ_CONF_ENV_FILE="$CONF_ENV_FILE"
    fi

    if [ -f "$RABBITMQ_CONF_ENV_FILE" ]
    then
        # shellcheck source=/dev/null
        . "$RABBITMQ_CONF_ENV_FILE"
    fi

    # We save the current value of $RABBITMQ_PID_FILE in case it was set by
    # an init script. If $CONF_ENV_FILE overrides it again, we must ignore
    # it and warn the user.
    _rmq_env_saved_RABBITMQ_PID_FILE="$RABBITMQ_PID_FILE"
    unset RABBITMQ_PID_FILE

    return 0
}

_rmq_env_cleanup()
{
    # temp vars
    unset _rmq_env_0

    # _rmq_env_config_plugins vars
    unset _rmq_env_plugins_configured
    unset _rmq_env_plugins_dir_source
    unset _rmq_env_enabled_plugins_file_source

    # _rmq_env_config_logs vars
    unset _rmq_env_logs_configured

    # _rmq_env_config_mnesia_dirs vars
    # Note: do *not* unset _rmq_env_mnesia_dirs_configured
    # as the run_escript function depends on it

    # _rmq_env_initialize vars
    unset _rmq_env_saved_RABBITMQ_PID_FILE

    # _rmq_env_config_schema_dir vars
    unset _rmq_env_schema_dir_configured
}

_rmq_env_realpath()
{
    _rmq_env_path="$1"
    if [ -d "$_rmq_env_path" ]; then
        cd "$_rmq_env_path" && pwd
    elif [ -f "$_rmq_env_path" ]; then
        cd "$(dirname "$_rmq_env_path")" && echo "$(pwd)/$(basename "$_rmq_env_path")"
    else
        echo "$_rmq_env_path"
    fi
    unset _rmq_env_path
}

_rmq_env_get_noex()
{
    if [ "x" = "x$1" ]; then
        echo ""
    else
        _rmq_env_basename="$(basename "$1")"
        _rmq_env_dirname="$(dirname "$1")"
        if [ "x." = "x${_rmq_env_dirname}" ]; then
            echo "${_rmq_env_basename%.*}"
        else
            echo "$_rmq_env_dirname/${_rmq_env_basename%.*}"
        fi
    fi
    unset _rmq_env_dirname
    unset _rmq_env_basename
}

_rmq_env_normalize_path()
{
    _rmq_env_path="$1"
    # Remove redundant slashes and strip a trailing slash for a
    # PATH-like vars - ':' is the delimiter
    echo "$_rmq_env_path" | sed -e 's#/\{2,\}#/#g' -e 's#/$##' -e 's#/:#:#g'
    unset _rmq_env_path
}

_rmq_env_normalize_path_var()
{
    _rmq_env_var=''
    _rmq_env_warning=''
    _rmq_env_prefix='WARNING:'

    for _rmq_env_var in "$@"; do
        _path=$(eval "echo \"\$$_rmq_env_var\"")
        case "$_path" in
        */)
            _rmq_env_warning=1
            echo "$_rmq_env_prefix Removing trailing slash from $_rmq_env_var" 1>&2
            ;;
        esac

        eval "$_rmq_env_var=$(_rmq_env_normalize_path "$_path")"

        if [ "x$_rmq_env_warning" = "x1" ]; then
            _rmq_env_prefix='        '
        fi
    done
    unset _rmq_env_var
    unset _rmq_env_warning
    unset _rmq_env_prefix
}

_rmq_check_if_shared_with_mnesia()
{
    _rmq_env_var=''
    _rmq_env_warning=''
    _rmq_env_prefix='WARNING:'

    if [ "$_rmq_env_mnesia_dirs_configured" != 'true' ]
    then
        _rmq_env_perr '_rmq_env_config_mnesia_dirs is not true (_rmq_check_if_shared_with_mnesia)'
        return 1
    fi

    _rmq_env_mnesia_dir="$(_rmq_env_realpath "$RABBITMQ_MNESIA_DIR")"

    for _rmq_env_var in "$@"; do
        _dir=$(eval "echo \"\$$_rmq_env_var\"")

        case $(_rmq_env_realpath "$_dir") in
        $_rmq_env_mnesia_dir)
            _rmq_env_warning=1
            echo "$_rmq_env_prefix $_rmq_env_var is equal to RABBITMQ_MNESIA_DIR" 1>&2
            ;;
        $_rmq_env_mnesia_dir/*)
            _rmq_env_warning=1
            echo "$_rmq_env_prefix $_rmq_env_var is located inside RABBITMQ_MNESIA_DIR" 1>&2
            ;;
        esac

        if [ "x$_rmq_env_warning" = "x1" ]; then
            _rmq_env_prefix="        "
        fi
    done

    if [ "x$_rmq_env_warning" = "x1" ]; then
        echo "$_rmq_env_prefix => Auto-clustering will not work ('cluster_nodes' in rabbitmq.config)" 1>&2
    fi
    unset _rmq_env_var
    unset _rmq_env_warning
    unset _rmq_env_prefix
    unset _rmq_env_mnesia_dir
}

_rmq_env_path_contains_existing_directory()
{
    _rmq_env_path="${1:?}"
    _rmq_env_dir=''
    IFS="
    "
    for _rmq_env_dir in $(echo "$_rmq_env_path" | tr ':' '\n'); do
        if [ -d "$_rmq_env_dir" ]; then
            return 0
        fi
    done
    unset IFS
    unset _rmq_env_path
    unset _rmq_env_dir
    return 1
}

_rmq_env_config_addr_ports()
{
    _rmq_env_default_node_port=5672

    [ -z "$RABBITMQ_NODE_PORT" ] && RABBITMQ_NODE_PORT="$NODE_PORT"
    [ -z "$RABBITMQ_DIST_PORT" ] && RABBITMQ_DIST_PORT="$DIST_PORT"

    [ -z "$RABBITMQ_DIST_PORT" ] && [ -z "$RABBITMQ_NODE_PORT" ] && \
        RABBITMQ_DIST_PORT="$((_rmq_env_default_node_port + 20000))"
    [ -z "$RABBITMQ_DIST_PORT" ] && [ -n "$RABBITMQ_NODE_PORT" ] && \
        RABBITMQ_DIST_PORT="$((RABBITMQ_NODE_PORT + 20000))"

    [ -z "$RABBITMQ_CTL_DIST_PORT_MIN" ] && RABBITMQ_CTL_DIST_PORT_MIN="$CTL_DIST_PORT_MIN"
    [ -z "$RABBITMQ_CTL_DIST_PORT_MAX" ] && RABBITMQ_CTL_DIST_PORT_MAX="$CTL_DIST_PORT_MAX"
    [ -z "$RABBITMQ_CTL_DIST_PORT_MIN" ] && RABBITMQ_CTL_DIST_PORT_MIN="$((RABBITMQ_DIST_PORT + 10000))"
    [ -z "$RABBITMQ_CTL_DIST_PORT_MAX" ] && RABBITMQ_CTL_DIST_PORT_MAX="$((RABBITMQ_DIST_PORT + 10010))"

    [ -z "$RABBITMQ_NODE_IP_ADDRESS" ] && RABBITMQ_NODE_IP_ADDRESS="$NODE_IP_ADDRESS"

    [ -z "$RABBITMQ_NODE_IP_ADDRESS" ] && [ -n "$RABBITMQ_NODE_PORT" ] && \
        RABBITMQ_NODE_IP_ADDRESS='auto'
    [ -n "$RABBITMQ_NODE_IP_ADDRESS" ] && [ -z "$RABBITMQ_NODE_PORT" ] && \
        RABBITMQ_NODE_PORT="$_rmq_env_default_node_port"

    unset _rmq_env_default_node_port
    return 0
}

_rmq_env_config_names()
{
    [ -z "$RABBITMQ_USE_LONGNAME" ] && RABBITMQ_USE_LONGNAME="$USE_LONGNAME"

    if [ 'xtrue' = "x$RABBITMQ_USE_LONGNAME" ]; then
        # shellcheck disable=SC2034
        RABBITMQ_NAME_TYPE='-name'
        [ -z "$HOSTNAME" ] && HOSTNAME="$(hostname -f)"
        [ -z "$NODENAME" ] && NODENAME="rabbit@$HOSTNAME"
    else
        # shellcheck disable=SC2034
        RABBITMQ_NAME_TYPE='-sname'
        [ -z "$HOSTNAME" ] && HOSTNAME="$(hostname)"
        [ -z "$NODENAME" ] && NODENAME="rabbit@${HOSTNAME%%.*}"
    fi

    [ -z "$RABBITMQ_NODENAME" ] && RABBITMQ_NODENAME="$NODENAME"
    return 0
}

_rmq_env_config_mnesia_dirs()
{
    [ -z "$RABBITMQ_MNESIA_BASE" ] && RABBITMQ_MNESIA_BASE="$MNESIA_BASE"
    [ -z "$RABBITMQ_MNESIA_DIR" ] && RABBITMQ_MNESIA_DIR="$MNESIA_DIR"
    [ -z "$RABBITMQ_MNESIA_DIR" ] && RABBITMQ_MNESIA_DIR="$RABBITMQ_MNESIA_BASE/$RABBITMQ_NODENAME"

    _rmq_env_normalize_path_var \
        RABBITMQ_MNESIA_BASE \
        RABBITMQ_MNESIA_DIR

    _rmq_env_mnesia_dirs_configured='true'
    return 0
}

_rmq_env_config_plugins()
{
    # NOTE: requires RABBITMQ_MNESIA_BASE
    if [ "$_rmq_env_mnesia_dirs_configured" != 'true' ]
    then
        _rmq_env_perr '_rmq_env_config_mnesia_dirs is not true (_rmq_env_config_plugins)'
        return 1
    fi

    [ -z "$RABBITMQ_PLUGINS_EXPAND_DIR" ] && RABBITMQ_PLUGINS_EXPAND_DIR="$PLUGINS_EXPAND_DIR"
    [ -z "$RABBITMQ_PLUGINS_EXPAND_DIR" ] && \
        RABBITMQ_PLUGINS_EXPAND_DIR="$RABBITMQ_MNESIA_BASE/${RABBITMQ_NODENAME}-plugins-expand"

    [ -n "$RABBITMQ_ENABLED_PLUGINS_FILE" ] && _rmq_env_enabled_plugins_file_source='environment'
    [ -z "$RABBITMQ_ENABLED_PLUGINS_FILE" ] && RABBITMQ_ENABLED_PLUGINS_FILE="$ENABLED_PLUGINS_FILE"

    [ -n "$RABBITMQ_PLUGINS_DIR" ] && _rmq_env_plugins_dir_source='environment'
    [ -z "$RABBITMQ_PLUGINS_DIR" ] && RABBITMQ_PLUGINS_DIR="$PLUGINS_DIR"

    _rmq_env_normalize_path_var RABBITMQ_PLUGINS_EXPAND_DIR \
        RABBITMQ_ENABLED_PLUGINS_FILE \
        RABBITMQ_PLUGINS_DIR

    _rmq_env_plugins_configured='true'
    return 0
}

_rmq_env_config_logs()
{
    [ -z "$RABBITMQ_LOG_BASE" ] && RABBITMQ_LOG_BASE="$LOG_BASE"
    _rmq_env_normalize_path_var RABBITMQ_LOG_BASE

    ## Log rotation
    [ -z "$RABBITMQ_LOGS" ] && RABBITMQ_LOGS="$LOGS"

    # NOTE: RABBITMQ_LOGS_source is read by sub-processes which is
    # why it is exported
    [ -n "$RABBITMQ_LOGS" ] && export RABBITMQ_LOGS_source='environment'
    [ -z "$RABBITMQ_LOGS" ] && RABBITMQ_LOGS="$RABBITMQ_LOG_BASE/$RABBITMQ_NODENAME.log"

    # shellcheck disable=SC2154
    [ -z "$RABBITMQ_UPGRADE_LOG" ] && RABBITMQ_UPGRADE_LOG="$RABBITMQ_LOG_BASE/${RABBITMQ_NODENAME}_upgrade.log"

    _rmq_env_normalize_path_var RABBITMQ_LOGS \
        RABBITMQ_UPGRADE_LOG

    _rmq_env_logs_configured='true'
    return 0
}

_rmq_env_config_schema_dir()
{
    [ -z "$RABBITMQ_SCHEMA_DIR" ] && RABBITMQ_SCHEMA_DIR="$SCHEMA_DIR"
    _rmq_env_schema_dir_configured='true'
    return 0
}

_rmq_env_misc()
{
    [ -z "$RABBITMQ_IO_THREAD_POOL_SIZE" ] && RABBITMQ_IO_THREAD_POOL_SIZE="$IO_THREAD_POOL_SIZE"

    [ -z "$RABBITMQ_SERVER_CODE_PATH" ] && RABBITMQ_SERVER_CODE_PATH="$SERVER_CODE_PATH"

    [ -z "$RABBITMQ_IGNORE_SIGINT" ] && RABBITMQ_IGNORE_SIGINT='true'
    # shellcheck disable=SC2034
    [ 'xtrue' = "x$RABBITMQ_IGNORE_SIGINT" ] && RABBITMQ_IGNORE_SIGINT_FLAG="+B i"

    [ -z "$ERL_CRASH_DUMP" ] && ERL_CRASH_DUMP="$RABBITMQ_LOG_BASE/erl_crash.dump"
}

_rmq_env_config_start_args()
{
    [ -z "$RABBITMQ_BOOT_MODULE" ] && RABBITMQ_BOOT_MODULE="$BOOT_MODULE"
    [ -z "$RABBITMQ_ALLOW_INPUT" ] && _rmq_env_noinput_arg='-noinput'
    [ -z "$RABBITMQ_NODE_ONLY" ] && _rmq_env_node_only_arg="-s $RABBITMQ_BOOT_MODULE boot"
    [ -n "$_rmq_env_noinput_arg" ] && [ -n "$_rmq_env_node_only_arg" ] && _rmq_env_maybe_space=' '

    # shellcheck disable=SC2034
    _rmq_env_start_rabbit="${_rmq_env_noinput_arg}${_rmq_env_maybe_space}${_rmq_env_node_only_arg}"

    unset _rmq_env_noinput_arg
    unset _rmq_env_node_only_arg
    unset _rmq_env_maybe_space
    return 0
}

_rmq_env_config_alloc_args()
{
    # The default allocation strategy RabbitMQ is using was introduced
    # in Erlang/OTP 20.2.3. Earlier Erlang versions fail to start with
    # this configuration. We therefore need to ensure that erl accepts
    # these values before we can use them.
    #
    # The defaults are meant to reduce RabbitMQ's memory usage and help
    # it reclaim memory at the cost of a slight decrease in performance
    # (due to an increase in memory operations). These defaults can be
    # overriden using the RABBITMQ_SERVER_ERL_ARGS variable.
    # shellcheck disable=SC2034
    #
    # Note: the default value is
    #   +MBas ageffcbf
    #   +MHas ageffcbf
    #   +MBlmbcs 512
    #   +MHlmbcs 512
    #   +MMmcs 30
    [ -z "$ALLOC_ARGS" ] && ALLOC_ARGS="+MBas ageffcbf +MHas ageffcbf +MBlmbcs 512 +MHlmbcs 512 +MMmcs 30"
    [ -z "$RABBITMQ_ALLOC_ARGS" ] && RABBITMQ_ALLOC_ARGS="$ALLOC_ARGS"
    return 0
}

_rmq_env_config_process_limit_arg()
{
    # Note: default value is 1048576
    [ -z "$MAX_NUMBER_OF_PROCESSES" ] && MAX_NUMBER_OF_PROCESSES=1048576
    [ -z "$RABBITMQ_MAX_NUMBER_OF_PROCESSES" ] && RABBITMQ_MAX_NUMBER_OF_PROCESSES="$MAX_NUMBER_OF_PROCESSES"
    return 0
}

_rmq_env_config_atom_limit_arg()
{
    # Note: default value is 5000000
    [ -z "$MAX_NUMBER_OF_ATOMS" ] && MAX_NUMBER_OF_ATOMS=5000000
    [ -z "$RABBITMQ_MAX_NUMBER_OF_ATOMS" ] && RABBITMQ_MAX_NUMBER_OF_ATOMS="$MAX_NUMBER_OF_ATOMS"
    return 0
}

_rmq_env_config_scheduler_bind_type_arg()
{
    # Note: default value is 'db'
    [ -z "$SCHEDULER_BIND_TYPE" ] && SCHEDULER_BIND_TYPE='db'
    [ -z "$RABBITMQ_SCHEDULER_BIND_TYPE" ] && RABBITMQ_SCHEDULER_BIND_TYPE="$SCHEDULER_BIND_TYPE"
    return 0
}

_rmq_env_config_distribution_buffer_arg()
{
    # Note: default value is 128000
    [ -z "$DISTRIBUTION_BUFFER_SIZE" ] && DISTRIBUTION_BUFFER_SIZE=128000
    [ -z "$RABBITMQ_DISTRIBUTION_BUFFER_SIZE" ] && RABBITMQ_DISTRIBUTION_BUFFER_SIZE="$DISTRIBUTION_BUFFER_SIZE"
    return 0
}

_rmq_env_config_erl_args()
{
    _rmq_env_config_process_limit_arg
    _rmq_env_config_atom_limit_arg
    _rmq_env_config_scheduler_bind_type_arg
    _rmq_env_config_distribution_buffer_arg

    # Note: default value is
    #   +P $RABBITMQ_MAX_NUMBER_OF_PROCESSES
    #   +t $RABBITMQ_MAX_NUMBER_OF_ATOMS
    #   +stbt $RABBITMQ_SCHEDULER_BIND_TYPE
    #   +zdbbl $RABBITMQ_DISTRIBUTION_BUFFER_SIZE
    [ -z "$SERVER_ERL_ARGS" ] && SERVER_ERL_ARGS=" +P $RABBITMQ_MAX_NUMBER_OF_PROCESSES +t $RABBITMQ_MAX_NUMBER_OF_ATOMS +stbt $RABBITMQ_SCHEDULER_BIND_TYPE +zdbbl $RABBITMQ_DISTRIBUTION_BUFFER_SIZE "
    [ -z "$RABBITMQ_SERVER_ERL_ARGS" ] && RABBITMQ_SERVER_ERL_ARGS="$SERVER_ERL_ARGS"

    [ -z "$RABBITMQ_CTL_ERL_ARGS" ] && RABBITMQ_CTL_ERL_ARGS="$CTL_ERL_ARGS"
    [ -z "$RABBITMQ_SERVER_START_ARGS" ] && RABBITMQ_SERVER_START_ARGS="$SERVER_START_ARGS"
    [ -z "$RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS" ] && RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS="$SERVER_ADDITIONAL_ERL_ARGS"

    return 0
}

_rmq_env_config_pid_file()
{
    if [ "$_rmq_env_mnesia_dirs_configured" != 'true' ]
    then
        _rmq_env_perr '_rmq_env_config_mnesia_dirs is not true (_rmq_env_config_pid_file)'
        return 1
    fi

    [ -z "$RABBITMQ_PID_FILE" ] && RABBITMQ_PID_FILE="$PID_FILE"
    [ -z "$RABBITMQ_PID_FILE" ] && RABBITMQ_PID_FILE="$RABBITMQ_MNESIA_DIR.pid"

    if [ -n "$_rmq_env_saved_RABBITMQ_PID_FILE" ] && \
        [ "$_rmq_env_saved_RABBITMQ_PID_FILE" != "$RABBITMQ_PID_FILE" ]
    then
        if [ -z "$RABBITMQ_DEV_ENV" ]
        then
            echo "$(_rmq_env_now) [warning]: RABBITMQ_PID_FILE was already set in the environment to:" 1>&2
            echo "                               '$_rmq_env_saved_RABBITMQ_PID_FILE'" 1>&2
            echo '                               Ignoring the default value and/or the value set in rabbitmq-env.conf' 1>&2
        fi
        RABBITMQ_PID_FILE="$_rmq_env_saved_RABBITMQ_PID_FILE"
    fi

    _rmq_env_normalize_path_var RABBITMQ_PID_FILE

    return 0
}

_rmq_env_config_erl_libs()
{
    ## Development-specific environment.
    if [ -n "$RABBITMQ_DEV_ENV" ]; then
        if [ "$_rmq_env_plugins_dir_source" != 'environment' ] || \
            [ "$_rmq_env_enabled_plugins_file_source" != 'environment' ]; then

            if [ "$_rmq_env_mnesia_dirs_configured" != 'true' ]
            then
                _rmq_env_perr '_rmq_env_config_mnesia_dirs is not true (_rmq_env_config_erl_libs)'
                return 1
            fi

            if [ "$_rmq_env_plugins_configured" != 'true' ]
            then
                _rmq_env_perr '_rmq_env_plugins_configured is not true (_rmq_env_config_erl_libs)'
                return 1
            fi

            # We need to query the running node for the plugins directory
            # and the "enabled plugins" file, which is why the RABBITMQ_MNESIA_*
            # variables are not exported here
            _rmq_env_plugins_dir=''
            _rmq_env_enabled_plugins_file=''
            _rmq_env_mnesia_base=''
            _rmq_env_mnesia_dir=''
            _rmq_env_tmp="$("$RABBITMQ_SCRIPTS_DIR/rabbitmqctl" eval \
                '{ok, P} = application:get_env(rabbit, plugins_dir),
                 {ok, E} = application:get_env(rabbit, enabled_plugins_file),
                 B = os:getenv("RABBITMQ_MNESIA_BASE"),
                 M = os:getenv("RABBITMQ_MNESIA_DIR"),
                 ok = io:format("_rmq_env_plugins_dir=\"~s\"~n"
                                "_rmq_env_enabled_plugins_file=\"~s\"~n"
                                "_rmq_env_mnesia_base=\"~s\"~n"
                                "_rmq_env_mnesia_dir=\"~s\"~n", [P, E, B, M]).' 2>/dev/null | grep -E '^_rmq_env' || :)"
            eval "$_rmq_env_tmp"
            if [ -n "$_rmq_env_plugins_dir" ] &&  \
                [ "$_rmq_env_plugins_dir_source" != 'environment' ]; then
                RABBITMQ_PLUGINS_DIR="$_rmq_env_plugins_dir"
            fi
            if [ -n "$_rmq_env_enabled_plugins_file" ] && \
                [ "$_rmq_env_enabled_plugins_file_source" != 'environment' ]; then
                RABBITMQ_ENABLED_PLUGINS_FILE="$_rmq_env_enabled_plugins_file"
            fi
            # shellcheck disable=SC2154
            if [ -n "$_rmq_env_mnesia_base" ] && \
                [ "$RABBITMQ_MNESIA_BASE_source" != 'environment' ]; then
                RABBITMQ_MNESIA_BASE="$_rmq_env_mnesia_base"
            fi
            # shellcheck disable=SC2154
            if [ -n "$_rmq_env_mnesia_dir" ] && \
                [ "$RABBITMQ_MNESIA_DIR_source" != 'environment' ]; then
                RABBITMQ_MNESIA_DIR="$_rmq_env_mnesia_dir"
            fi
            unset _rmq_env_plugins_dir
            unset _rmq_env_enabled_plugins_file
            unset _rmq_env_mnesia_base
            unset _rmq_env_mnesia_dir
            unset _rmq_env_tmp
        fi

        if _rmq_env_path_contains_existing_directory "$RABBITMQ_PLUGINS_DIR"; then
            # RabbitMQ was started with "make run-broker" from its own
            # source tree. Take rabbit_common from the plugins directory.
            ERL_LIBS="$RABBITMQ_PLUGINS_DIR:$ERL_LIBS"
        else
            # RabbitMQ runs from a testsuite or a plugin. The .ez files are
            # not available under RabbitMQ source tree. We need to look at
            # $DEPS_DIR and default locations.
            if [ -n "$DEPS_DIR" ] && [ -d "$DEPS_DIR/rabbit_common/ebin" ]; then
                # $DEPS_DIR is set, and it contains rabbitmq-common, use
                # this.
                _rmq_env_deps_dir_norm="$DEPS_DIR"
            elif [ -f "$RABBITMQ_SCRIPTS_DIR/../../../erlang.mk" ] && \
                [ -d "$RABBITMQ_SCRIPTS_DIR/../../rabbit_common/ebin" ]; then
                # Look at default locations: "deps" subdirectory inside a
                # plugin or the Umbrella.
                _rmq_env_deps_dir_norm="$RABBITMQ_SCRIPTS_DIR/../.."
            fi
            _rmq_env_deps_dir_norm="$(_rmq_env_realpath "$_rmq_env_deps_dir_norm")"
            ERL_LIBS="$_rmq_env_deps_dir_norm:$ERL_LIBS"
            unset _rmq_env_deps_dir_norm
        fi
    else
        if _rmq_env_path_contains_existing_directory "$RABBITMQ_PLUGINS_DIR"; then
            # RabbitMQ was started from its install directory. Take
            # rabbit_common from the plugins directory.
            ERL_LIBS="$RABBITMQ_PLUGINS_DIR:$ERL_LIBS"
        fi
    fi

    ERL_LIBS="${ERL_LIBS%:}"
    if [ -n "$ERL_LIBS" ]; then
        export ERL_LIBS
    fi

    return 0
}

_rmq_env_config_config_files()
{
    if [ "$_rmq_env_schema_dir_configured" != 'true' ]
    then
        _rmq_env_perr '_rmq_env_schema_dir_configured is not true (_rmq_env_config_config_files)'
        return 1
    fi

    [ -z "$RABBITMQ_CONFIG_FILE" ] && RABBITMQ_CONFIG_FILE="$CONFIG_FILE"
    [ -z "$RABBITMQ_GENERATED_CONFIG_DIR" ] && RABBITMQ_GENERATED_CONFIG_DIR="$GENERATED_CONFIG_DIR"
    [ -z "$RABBITMQ_ADVANCED_CONFIG_FILE" ] && RABBITMQ_ADVANCED_CONFIG_FILE="$ADVANCED_CONFIG_FILE"

    _rmq_env_normalize_path_var RABBITMQ_CONFIG_FILE

    # Check that advanced config file has the .config extension
    # Add .config extension if it's empty
    _rmq_env_advanced_config_file_noex="$(_rmq_env_get_noex "$RABBITMQ_ADVANCED_CONFIG_FILE")"
    if [ "$_rmq_env_advanced_config_file_noex.config" = "$RABBITMQ_ADVANCED_CONFIG_FILE" ] || \
        [ "$_rmq_env_advanced_config_file_noex" = "$RABBITMQ_ADVANCED_CONFIG_FILE" ]; then
        RABBITMQ_ADVANCED_CONFIG_FILE="$_rmq_env_advanced_config_file_noex.config"
    fi

    _rmq_env_config_file_noex="$(_rmq_env_get_noex "$RABBITMQ_CONFIG_FILE")"

    # Extension is not specified.
    # Determine config type from file
    if [ "$_rmq_env_config_file_noex" = "$RABBITMQ_CONFIG_FILE" ]; then
        if [ -f "$_rmq_env_config_file_noex.config" ]; then
            if [ -f "$_rmq_env_config_file_noex.conf" ]; then
                # Both files exist. Print a warning
                echo "WARNING: Both old (.config) and new (.conf) format config files exist."
                echo "WARNING: Using the old format config file: $_rmq_env_config_file_noex.config"
                echo "WARNING: Please update your config files to the new format and remove the old file"
            fi
            RABBITMQ_CONFIG_FILE="$_rmq_env_config_file_noex.config"
        elif [ -f "$_rmq_env_config_file_noex.conf" ]; then
            RABBITMQ_CONFIG_FILE="$_rmq_env_config_file_noex.conf"
        else
            if [ -f "$RABBITMQ_ADVANCED_CONFIG_FILE" ]; then
                echo "WARNING: Using RABBITMQ_ADVANCED_CONFIG_FILE: $RABBITMQ_ADVANCED_CONFIG_FILE"
            fi
            # No config file exist. Use advanced config for -config arg.
            RABBITMQ_CONFIG_ARG_FILE="$RABBITMQ_ADVANCED_CONFIG_FILE"
            RABBITMQ_CONFIG_FILE=""
        fi
    fi

    # Set the -config argument.
    # The -config argument should not have extension.
    # the file should exist
    # the file should be a valid erlang term file
    # Config file extension is .config
    if [ "$_rmq_env_config_file_noex.config" = "$RABBITMQ_CONFIG_FILE" ]; then
        RABBITMQ_CONFIG_ARG_FILE="$RABBITMQ_CONFIG_FILE"
    # Config file extension is .conf
    elif [ "$_rmq_env_config_file_noex.conf" = "$RABBITMQ_CONFIG_FILE" ]; then
        RABBITMQ_CONFIG_ARG_FILE="$RABBITMQ_ADVANCED_CONFIG_FILE"
    elif [ "x" != "x$RABBITMQ_CONFIG_FILE" ] && \
        [ "$_rmq_env_config_file_noex" != "$RABBITMQ_CONFIG_FILE" ]; then
        # Config file has an extension, but it's neither .conf or .config
        echo "ERROR: Wrong extension for RABBITMQ_CONFIG_FILE: $RABBITMQ_CONFIG_FILE" 2>&1
        echo "ERROR: extension should be either .conf or .config" 2>&1
        return 1
    fi

    _rmq_env_config_arg_file_noex="$(_rmq_env_get_noex "$RABBITMQ_CONFIG_ARG_FILE")"

    if [ "$_rmq_env_config_arg_file_noex.config" != "$RABBITMQ_CONFIG_ARG_FILE" ]; then
        if [ "$RABBITMQ_CONFIG_ARG_FILE" = "$RABBITMQ_ADVANCED_CONFIG_FILE" ]; then
            echo "ERROR: Wrong extension for RABBITMQ_ADVANCED_CONFIG_FILE: $RABBITMQ_ADVANCED_CONFIG_FILE" 2>&1
            echo "ERROR: extension should be .config" 2>&1
            return 1
        else
            # We should never got here, but still there should be some explanation
            echo "ERROR: Wrong extension for $RABBITMQ_CONFIG_ARG_FILE" 2>&1
            echo "ERROR: extension should be .config" 2>&1
            return 1
        fi
    fi

    # Set -config if the file exists
    if [ -f "$RABBITMQ_CONFIG_ARG_FILE" ]; then
        # shellcheck disable=SC2034
        RABBITMQ_CONFIG_ARG="-config $_rmq_env_config_arg_file_noex"
    fi

    # Set -conf and other generated config parameters
    if [ "$_rmq_env_config_file_noex.conf" = "$RABBITMQ_CONFIG_FILE" ]; then
        # shellcheck disable=SC2034
        RABBITMQ_GENERATED_CONFIG_ARG="-conf $RABBITMQ_CONFIG_FILE \
                                    -conf_dir $RABBITMQ_GENERATED_CONFIG_DIR \
                                    -conf_script_dir $(dirname "$_rmq_env_0") \
                                    -conf_schema_dir $RABBITMQ_SCHEMA_DIR
                                    -conf_advanced $RABBITMQ_ADVANCED_CONFIG_FILE"
    fi

    unset _rmq_env_advanced_config_file_noex
    unset _rmq_env_config_file_noex
    unset _rmq_env_config_arg_file_noex
    return 0
}

_rmq_env_validate()
{
    # Check if files and directories non-related to Mnesia are configured
    # to be in $RABBITMQ_MNESIA_DIR. If this is the case, issue a warning
    # because it will prevent auto-clustering from working (the node will be
    # considered non-virgin).
    # TODO: add other config file paths?
    if ! _rmq_check_if_shared_with_mnesia RABBITMQ_CONFIG_FILE RABBITMQ_LOG_BASE \
                                          RABBITMQ_PID_FILE RABBITMQ_PLUGINS_EXPAND_DIR \
                                          RABBITMQ_ENABLED_PLUGINS_FILE RABBITMQ_PLUGINS_DIR \
                                          RABBITMQ_LOGS RABBITMQ_UPGRADE_LOG
    then
        return 1
    fi
}

run_escript()
{
    escript_main="${1:?escript_main must be defined}"
    shift
    escript="${1:?escript must be defined}"
    shift

    if [ "$_rmq_env_mnesia_dirs_configured" != 'true' ]
    then
        _rmq_env_perr '_rmq_env_config_mnesia_dirs is not true (run_escript)'
        return 1
    fi

    # shellcheck disable=SC2086
    exec "${ERL_DIR}erl" +B \
        -boot "$CLEAN_BOOT_FILE" \
        -noinput -noshell -hidden -smp enable \
        $RABBITMQ_CTL_ERL_ARGS \
        -kernel inet_dist_listen_min "$RABBITMQ_CTL_DIST_PORT_MIN" \
        -kernel inet_dist_listen_max "$RABBITMQ_CTL_DIST_PORT_MAX" \
        -sasl errlog_type error \
        -mnesia dir "\"$RABBITMQ_MNESIA_DIR\"" \
        -nodename "$RABBITMQ_NODENAME" \
        -run escript start \
        -escript main "$escript_main" \
        -extra "$escript" "$@"
}

rmq_env_config()
{
    _rmq_env_config_addr_ports
    _rmq_env_config_names
    _rmq_env_config_mnesia_dirs
    _rmq_env_config_plugins
    _rmq_env_config_logs
    _rmq_env_config_schema_dir
    _rmq_env_misc
    _rmq_env_config_start_args
    _rmq_env_config_alloc_args
    _rmq_env_config_erl_args
    _rmq_env_config_pid_file
    _rmq_env_config_erl_libs
    _rmq_env_config_config_files
    _rmq_env_validate
    return 0
}

# Note: this function must always be run
_rmq_env_0="$0"
_rmq_env_initialize

# Note: this is to emulate the expected behavior of rabbitmq-env, which is to
# run all configuration when sourced. Setting _rabbitmq_env_load to false prior
# to sourcing facilitates unit testing individual functions in this file without
# running them all
if [ "${_rabbitmq_env_load:-true}" = 'true' ]
then
    if ! rmq_env_config
    then
        _rmq_env_perr 'configuration failed, please see output'
        _rmq_env_cleanup
        return 1
    fi
    _rmq_env_cleanup
fi

RABBITMQ_ENV_LOADED=1

# Since we source this elsewhere, don't accidentally stop execution
true
